const std = @import("std");

pub const Token = union(enum(u8)) {
    const This = @This();

    // Literals
    label: []const u8,
    immediate: i64,
    immediate_label: []const u8,
    absolute: u32,
    char: u8,
    string: []const u8,

    // Single charchater tokens
    comma,
    left_parentheses,
    right_parentheses,
    plus,
    minus,
    multiply,
    divide,

    // Dual charchater tokens
    byte_size,
    word_size,
    long_size,
    data_register: u8,
    address_register: u8,

    // mnemonics (must be ketp sequential)
    abcd,
    add,
    adda,
    addi,
    addq,
    andd,
    andi,
    asl,
    asr,
    bcc,
    bchg,
    bclr,
    bra,
    bset,
    bsr,
    btst,
    chk,
    clr,
    cmp,
    cmpa,
    cmpi,
    cmpm,
    dbcc,
    dc,
    dcb,
    divs,
    ds,
    end,
    eor,
    eori,
    equ,
    exg,
    ext,
    illegal,
    jmp,
    jsr,
    lea,
    link,
    lsl,
    lsr,
    move,
    movea,
    movep,
    moveq,
    muls,
    mulu,
    nbcd,
    neg,
    negx,
    nop,
    not,
    org,
    ori,
    orr,
    pea,
    reg,
    reset,
    rol,
    ror,
    roxl,
    roxr,
    rte,
    rtr,
    rts,
    sbcd,
    scc,
    set,
    stop,
    sub,
    suba,
    subi,
    subq,
    subx,
    swap,
    tas,
    trap,
    trapv,
    tst,
    unlk,

    pub fn Types() type {
        return @typeInfo(@This()).Union.tag_type.?;
    }

    pub fn mnemonics() []const std.builtin.Type.EnumField {
        return @typeInfo(Types()).Enum.fields[@intFromEnum(Types().abcd)..];
    }
};
